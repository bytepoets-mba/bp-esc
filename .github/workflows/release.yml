name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  release:
    permissions:
      contents: write
    runs-on: macos-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          # cache: 'npm' # Removed temporarily as it causes issues if lockfile isn't synced correctly

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-apple-darwin, aarch64-apple-darwin

      - name: Rust Cache
        uses: Swatinem/rust-cache@v2
        with:
          # Use the same cache for all release tags to maximize hits
          shared-key: "release-build"
          workspaces: ". -> target"
          # Disable job-id key to allow cache persistence across different workflow runs
          add-job-id-key: false

      - name: Install dependencies
        run: npm ci

      - name: Download Sparkle Framework
        run: |
          cd src-tauri
          curl -L -o /tmp/sparkle.tar.xz "https://github.com/sparkle-project/Sparkle/releases/download/2.8.1/Sparkle-2.8.1.tar.xz"
          tar -xf /tmp/sparkle.tar.xz -C /tmp
          cp -R /tmp/Sparkle.framework .
          mkdir -p sparkle-bin
          cp -R /tmp/bin/* sparkle-bin/
          chmod +x sparkle-bin/*
          echo "Sparkle framework and tools installed"

      - name: Import Apple Certificate
        if: env.APPLE_CERTIFICATE != ''
        uses: apple-actions/import-codesign-certs@v3
        with:
          p12-file-base64: ${{ secrets.APPLE_CERTIFICATE }}
          p12-password: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}

      - name: Build Tauri app
        run: |
          npm run build:frontend
          npx tauri build --bundles app --target universal-apple-darwin
        env:
          CI: true
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: "Developer ID Application: BYTEPOETS GmbH"
          # This is critical for Notarization
          ENABLE_HARDENED_RUNTIME: true

      - name: Re-sign Sparkle Framework Binaries
        if: env.APPLE_CERTIFICATE != ''
        run: |
          set -e  # Exit on any error
          
          PRODUCT_NAME=$(node -e "console.log(require('./src-tauri/tauri.conf.json').productName)")
          APP_BUNDLE="target/universal-apple-darwin/release/bundle/macos/$PRODUCT_NAME.app"
          SPARKLE_FRAMEWORK="$APP_BUNDLE/Contents/Frameworks/Sparkle.framework"
          
          # Verify app bundle exists
          if [ ! -d "$APP_BUNDLE" ]; then
            echo "‚ùå App bundle not found at: $APP_BUNDLE"
            exit 1
          fi
          
          # Verify Sparkle framework exists
          if [ ! -d "$SPARKLE_FRAMEWORK" ]; then
            echo "‚ùå Sparkle framework not found at: $SPARKLE_FRAMEWORK"
            exit 1
          fi
          
          # Use the SAME signing identity that Tauri used (passed via env var)
          SIGNING_IDENTITY="$APPLE_SIGNING_IDENTITY"
          echo "‚úì Using identity: $SIGNING_IDENTITY"
          
          # Determine version directory (B is standard for Sparkle 2.x, but check both)
          if [ -d "$SPARKLE_FRAMEWORK/Versions/B" ]; then
            VERSION_DIR="Versions/B"
          elif [ -d "$SPARKLE_FRAMEWORK/Versions/A" ]; then
            VERSION_DIR="Versions/A"
          else
            echo "‚ùå Could not find Sparkle version directory (Versions/A or Versions/B)"
            exit 1
          fi
          
          echo "‚úì Found Sparkle at: $VERSION_DIR"
          echo "üîê Re-signing Sparkle binaries with hardened runtime (order matters!)..."
          
          # Sign in correct order: XPC services first, then Autoupdate, then framework
          # DO NOT use --deep flag (it corrupts XPC signatures)
          
          # 1. Sign Installer.xpc
          if [ -d "$SPARKLE_FRAMEWORK/$VERSION_DIR/XPCServices/Installer.xpc" ]; then
            echo "  ‚Üí Signing Installer.xpc"
            codesign --force --sign "$SIGNING_IDENTITY" \
              --options runtime \
              "$SPARKLE_FRAMEWORK/$VERSION_DIR/XPCServices/Installer.xpc"
          else
            echo "  ‚ö† Installer.xpc not found (may not be needed)"
          fi
          
          # 2. Sign Downloader.xpc (preserve entitlements for Sparkle 2.6+)
          if [ -d "$SPARKLE_FRAMEWORK/$VERSION_DIR/XPCServices/Downloader.xpc" ]; then
            echo "  ‚Üí Signing Downloader.xpc"
            codesign --force --sign "$SIGNING_IDENTITY" \
              --options runtime \
              --preserve-metadata=entitlements \
              "$SPARKLE_FRAMEWORK/$VERSION_DIR/XPCServices/Downloader.xpc"
          else
            echo "  ‚ö† Downloader.xpc not found (may not be needed)"
          fi
          
          # 3. Sign Autoupdate
          if [ -f "$SPARKLE_FRAMEWORK/$VERSION_DIR/Autoupdate" ]; then
            echo "  ‚Üí Signing Autoupdate"
            codesign --force --sign "$SIGNING_IDENTITY" \
              --options runtime \
              "$SPARKLE_FRAMEWORK/$VERSION_DIR/Autoupdate"
          else
            echo "  ‚ö† Autoupdate not found (may not be needed)"
          fi
          
          # 4. Sign the framework itself (REQUIRED)
          echo "  ‚Üí Signing Sparkle.framework"
          codesign --force --sign "$SIGNING_IDENTITY" \
            --options runtime \
            "$SPARKLE_FRAMEWORK"
          
          # Verify framework signature
          codesign --verify --verbose "$SPARKLE_FRAMEWORK"
          
          # 5. Re-sign the app bundle (without --deep to preserve our XPC signatures)
          echo "  ‚Üí Re-signing app bundle"
          codesign --force --sign "$SIGNING_IDENTITY" \
            --options runtime \
            --entitlements src-tauri/entitlements/release.entitlements \
            "$APP_BUNDLE"
          
          # Verify app signature
          codesign --verify --verbose "$APP_BUNDLE"
          
          echo "‚úì Sparkle framework and app re-signed successfully"
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_SIGNING_IDENTITY: "Developer ID Application: BYTEPOETS GmbH"

      - name: Notarize App Bundle
        if: env.APPLE_ID != ''
        run: |
          PRODUCT_NAME=$(node -e "console.log(require('./src-tauri/tauri.conf.json').productName)")
          APP_PATH="target/universal-apple-darwin/release/bundle/macos/$PRODUCT_NAME.app"
          ZIP_PATH="target/universal-apple-darwin/release/bundle/macos/$PRODUCT_NAME.zip"
          
          echo "üì¶ Zipping for notarization..."
          ditto -c -k --keepParent "$APP_PATH" "$ZIP_PATH"
          
          echo "üöÄ Submitting to Apple Notary Service..."
          SUBMISSION_OUTPUT=$(xcrun notarytool submit "$ZIP_PATH" \
            --apple-id "${{ secrets.APPLE_ID }}" \
            --password "${{ secrets.APPLE_PASSWORD }}" \
            --team-id "${{ secrets.APPLE_TEAM_ID }}" \
            --wait 2>&1)
          
          echo "$SUBMISSION_OUTPUT"
          
          # Extract submission ID
          SUBMISSION_ID=$(echo "$SUBMISSION_OUTPUT" | grep "id:" | head -1 | awk '{print $2}')
          
          # Check if notarization was successful
          if echo "$SUBMISSION_OUTPUT" | grep -q "status: Invalid"; then
            echo "‚ùå Notarization failed! Getting detailed log..."
            xcrun notarytool log "$SUBMISSION_ID" \
              --apple-id "${{ secrets.APPLE_ID }}" \
              --password "${{ secrets.APPLE_PASSWORD }}" \
              --team-id "${{ secrets.APPLE_TEAM_ID }}"
            exit 1
          fi
          
          echo "üé´ Stapling notarization ticket..."
          xcrun stapler staple "$APP_PATH"
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}

      - name: Build DMG via node-appdmg
        run: node scripts/build-dmg.js

      - name: Zip App for Sparkle
        run: |
          PRODUCT_NAME=$(node -e "console.log(require('./src-tauri/tauri.conf.json').productName)")
          APP_PATH="target/universal-apple-darwin/release/bundle/macos/$PRODUCT_NAME.app"
          ZIP_PATH="target/universal-apple-darwin/release/bundle/macos/$PRODUCT_NAME.zip"
          
          echo "üì¶ Creating Sparkle update zip..."
          ditto -c -k --keepParent "$APP_PATH" "$ZIP_PATH"

      - name: Generate Appcast
        run: |
          # Create output directory
          mkdir -p appcast-output
          
          # Copy .zip to output directory for appcast generation
          PRODUCT_NAME=$(node -e "console.log(require('./src-tauri/tauri.conf.json').productName)")
          cp "target/universal-apple-darwin/release/bundle/macos/$PRODUCT_NAME.zip" appcast-output/
          
          # Generate appcast.xml with EdDSA signature using the tool we downloaded earlier
          ./src-tauri/sparkle-bin/generate_appcast \
            --ed-key-file <(echo "${{ secrets.SPARKLE_PRIVATE_KEY }}") \
            --download-url-prefix "https://github.com/bytepoets-mba/bp-esc/releases/download/${{ github.ref_name }}/" \
            --link "https://github.com/bytepoets-mba/bp-esc" \
            --full-release-notes-url "https://github.com/bytepoets-mba/bp-esc/releases/tag/${{ github.ref_name }}" \
            appcast-output/
          
          # Move appcast.xml to root for release attachment
          mv appcast-output/appcast.xml .

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            target/universal-apple-darwin/release/bundle/dmg/*.dmg
            target/universal-apple-darwin/release/bundle/macos/*.zip
            appcast.xml
          draft: true
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
