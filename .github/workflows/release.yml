name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  release:
    permissions:
      contents: write
    runs-on: macos-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          # cache: 'npm' # Removed temporarily as it causes issues if lockfile isn't synced correctly

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-apple-darwin, aarch64-apple-darwin

      - name: Rust Cache
        uses: Swatinem/rust-cache@v2
        with:
          # Use the same cache for all release tags to maximize hits
          shared-key: "release-build"
          workspaces: ". -> target"
          # Disable job-id key to allow cache persistence across different workflow runs
          add-job-id-key: false

      - name: Install dependencies
        run: npm ci

      - name: Download Sparkle Framework
        run: |
          cd src-tauri
          curl -L -o /tmp/sparkle.tar.xz "https://github.com/sparkle-project/Sparkle/releases/download/2.8.1/Sparkle-2.8.1.tar.xz"
          tar -xf /tmp/sparkle.tar.xz -C /tmp
          cp -R /tmp/Sparkle.framework .
          mkdir -p sparkle-bin
          cp -R /tmp/bin/* sparkle-bin/
          chmod +x sparkle-bin/*
          echo "Sparkle framework and tools installed"

      - name: Import Apple Certificate
        uses: apple-actions/import-codesign-certs@v3
        with:
          p12-file-base64: ${{ secrets.APPLE_CERTIFICATE }}
          p12-password: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}

      - name: Pre-sign Sparkle Framework
        run: |
          set -e
          
          SPARKLE_FRAMEWORK="src-tauri/Sparkle.framework"
          
          echo "üîê Listing available signing identities..."
          security find-identity -v -p codesigning
          
          # Get the signing identity
          SIGNING_IDENTITY=$(security find-identity -v -p codesigning | grep "Developer ID Application" | head -1 | sed 's/.*"\(.*\)".*/\1/')
          
          if [ -z "$SIGNING_IDENTITY" ]; then
            echo "‚ùå No Developer ID Application certificate found"
            exit 1
          fi
          
          echo "‚úì Using identity: $SIGNING_IDENTITY"
          echo "üîê Pre-signing Sparkle binaries BEFORE Tauri build..."
          
          # Sign Updater.app
          if [ -d "$SPARKLE_FRAMEWORK/Versions/B/Updater.app" ]; then
            echo "  ‚Üí Signing Updater.app"
            codesign --force --sign "$SIGNING_IDENTITY" \
              --options runtime --timestamp \
              --deep \
              "$SPARKLE_FRAMEWORK/Versions/B/Updater.app"
          fi
          
          # Sign Autoupdate
          if [ -f "$SPARKLE_FRAMEWORK/Versions/B/Autoupdate" ]; then
            echo "  ‚Üí Signing Autoupdate"
            codesign --force --sign "$SIGNING_IDENTITY" \
              --options runtime --timestamp \
              "$SPARKLE_FRAMEWORK/Versions/B/Autoupdate"
          fi
          
          # Sign the framework itself
          echo "  ‚Üí Signing Sparkle.framework"
          codesign --force --sign "$SIGNING_IDENTITY" \
            --options runtime --timestamp \
            "$SPARKLE_FRAMEWORK"
          
          # Verify
          echo "üîç Verifying Sparkle signature..."
          codesign --verify --verbose "$SPARKLE_FRAMEWORK"
          
          echo "‚úì Sparkle framework pre-signed"

      - name: Build Tauri app
        run: |
          npm run build:frontend
          npx tauri build --bundles app --target universal-apple-darwin
        env:
          CI: true
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: "Developer ID Application: BYTEPOETS GmbH"
          ENABLE_HARDENED_RUNTIME: true

      # NO re-signing after build - Tauri seals the pre-signed framework

      - name: Notarize App Bundle
        if: env.APPLE_ID != ''
        run: |
          PRODUCT_NAME=$(node -e "console.log(require('./src-tauri/tauri.conf.json').productName)")
          APP_PATH="target/universal-apple-darwin/release/bundle/macos/$PRODUCT_NAME.app"
          ZIP_PATH="target/universal-apple-darwin/release/bundle/macos/$PRODUCT_NAME.zip"
          
          echo "üì¶ Zipping for notarization..."
          ditto -c -k --keepParent "$APP_PATH" "$ZIP_PATH"
          
          echo "üöÄ Submitting to Apple Notary Service..."
          SUBMISSION_OUTPUT=$(xcrun notarytool submit "$ZIP_PATH" \
            --apple-id "${{ secrets.APPLE_ID }}" \
            --password "${{ secrets.APPLE_PASSWORD }}" \
            --team-id "${{ secrets.APPLE_TEAM_ID }}" \
            --wait 2>&1)
          
          echo "$SUBMISSION_OUTPUT"
          
          # Extract submission ID
          SUBMISSION_ID=$(echo "$SUBMISSION_OUTPUT" | grep "id:" | head -1 | awk '{print $2}')
          
          # Check if notarization was successful
          if echo "$SUBMISSION_OUTPUT" | grep -q "status: Invalid"; then
            echo "‚ùå Notarization failed! Getting detailed log..."
            xcrun notarytool log "$SUBMISSION_ID" \
              --apple-id "${{ secrets.APPLE_ID }}" \
              --password "${{ secrets.APPLE_PASSWORD }}" \
              --team-id "${{ secrets.APPLE_TEAM_ID }}"
            exit 1
          fi
          
          echo "üé´ Stapling notarization ticket..."
          xcrun stapler staple "$APP_PATH"
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}

      - name: Build DMG via node-appdmg
        run: node scripts/build-dmg.js

      - name: Zip App for Sparkle
        run: |
          PRODUCT_NAME=$(node -e "console.log(require('./src-tauri/tauri.conf.json').productName)")
          APP_PATH="target/universal-apple-darwin/release/bundle/macos/$PRODUCT_NAME.app"
          ZIP_PATH="target/universal-apple-darwin/release/bundle/macos/$PRODUCT_NAME.zip"
          
          echo "üì¶ Creating Sparkle update zip..."
          ditto -c -k --keepParent "$APP_PATH" "$ZIP_PATH"

      - name: Generate Appcast
        run: |
          # Create output directory
          mkdir -p appcast-output
          
          # Copy .zip to output directory for appcast generation
          PRODUCT_NAME=$(node -e "console.log(require('./src-tauri/tauri.conf.json').productName)")
          cp "target/universal-apple-darwin/release/bundle/macos/$PRODUCT_NAME.zip" appcast-output/
          
          # Generate appcast.xml with EdDSA signature using the tool we downloaded earlier
          ./src-tauri/sparkle-bin/generate_appcast \
            --ed-key-file <(echo "${{ secrets.SPARKLE_PRIVATE_KEY }}") \
            --download-url-prefix "https://github.com/bytepoets-mba/bp-esc/releases/download/${{ github.ref_name }}/" \
            --link "https://github.com/bytepoets-mba/bp-esc" \
            --full-release-notes-url "https://github.com/bytepoets-mba/bp-esc/releases/tag/${{ github.ref_name }}" \
            appcast-output/
          
          # Move appcast.xml to root for release attachment
          mv appcast-output/appcast.xml .

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            target/universal-apple-darwin/release/bundle/dmg/*.dmg
            target/universal-apple-darwin/release/bundle/macos/*.zip
            appcast.xml
          draft: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
